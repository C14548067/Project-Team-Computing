#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Prototype
void lineCount_fxn();

task main()
{

	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

	//Call lineCount_fxn()
	lineCount_fxn();


}//End main()

//Implement lineCount_fxn()
void lineCount_fxn()
{
	int countValue = 0;
	int lastSeen = 1;

	while(1 == 1)
	{
		if(SensorValue(lightSensor) < 35)
		{
			motor[motorB] = 0;
			motor[motorC] = 0;
			nMotorEncoder[motorB] = 0;
			countValue = countValue + 1;
			nxtDisplayCenteredTextLine(5, "Lines passed: %d", countValue);

			while(nMotorEncoder[motorB] < 260)	//While motor has moved less than one square
			{
				motor[motorB] = 25;
				motor[motorC] = 25;
			}//End while

			motor[motorB] = 0;
			motor[motorC] = 0;
			nMotorEncoder[motorB] = 0;

			if(SensorValue(lightSensor) < 35)		//If it runs into a black cell
			{
				nxtDisplayCenteredTextLine(4, "Black Cell");
				//Reverse one square function here
				while(nMotorEncoder[motorB] > -260)
				{
					motor[motorB] = -25;
					motor[motorC] = -25;
				}//End while

			}//End if

			else
			{
				countValue = countValue + 1;
				nxtDisplayCenteredTextLine(5, "Lines passed: %d", countValue);
				nxtDisplayCenteredTextLine(4, "White Cell");
				//Go forwards one square function here
				while(nMotorEncoder[motorB] < 260)
				{
					motor[motorB] = 25;
					motor[motorC] = 25;

				}//End while

				nMotorEncoder[motorB] = 0;

			}//End else

		}//End if

		else
		{
			motor[motorB] = 25;
			motor[motorC] = 25;
		}//End else

	}//End infinite while
}//End lineCount_fxn()

