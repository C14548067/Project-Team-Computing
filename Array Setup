#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Code for array setup in project */

//Prototypes

//To be used within the function where the robot moves forward
void direction_fxn(int direct, int x_val, int y_val, int blockpose1_x_val, int blockpose1_y_val, int blockpose2_x_val, int blockpose2_y_val, int array[7][9]);

task main()
{
	//Assigning variables

    int direct = 2;   //Used for the direction the robot is facing, initial direction being East
                      // 1 = North, 2 = East, 3 = South, 4 = West

    int x_val = 1;    //Used for X-axis values in grid at starting position
    int y_val = 4;    //Used for Y-axis values in grid at starting position

    int blockpose1_x_val = 0;
    int blockpose1_y_val = 0;

    int blockpose2_x_val = 0;
    int blockpose2_y_val = 0;


    //Array used for grid positioning
    int array[7][9] ={ { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
                       { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
                       { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
                       { 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },			//1 = white cell, 2 = black cell,
                       { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },			//3 = block, 4 = current position
                       { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },
                       { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } };

    /*              Movement based on current direction and block detection             */

    //Call direction_fxn
    direction_fxn(direct, x_val, y_val, blockpose1_x_val, blockpose1_y_val, blockpose2_x_val, blockpose2_y_val, array[7][9]);

}//End main()

//Implement direction_fxn()
void direction_fxn(int direct, int x_val, int y_val, int blockpose1_x_val, int blockpose1_y_val, int blockpose2_x_val, int blockpose2_y_val, int array[7][9])
{

	switch(direct)
	{

		//If facing North
		case 1:
		{

      if(SensorValue(sonarSensor) < 25)			//Detects block
      	{
      		blockpose1_x_val = x_val;
          blockpose1_y_val = y_val + 1;
          array[x_val][y_val + 1] = 4;
          //Turn or go backwards function
        }//End if

        else			//Goes forwards
        {
        	//Move forwards function
        	y_val++;
        }

      break;
		}//End case 1


		//If facing East
		case 2:
		{
			if(SensorValue(sonarSensor) < 25)			//Detects block
				{
        	blockpose1_x_val = x_val + 1;
          blockpose1_y_val = y_val;
          array[x_val + 1][y_val] = 4;
          //Turn or go backwards function
         }//End if

       else			//Goes forwards
       {
         //Move forwards function
				 x_val++;
			 }

			break;
		}//End case 2


		//If facing South
    case 3:
    {
        if(SensorValue(sonarSensor) < 25)			//Detects block
        	{
        		blockpose1_x_val = x_val;
        		blockpose1_y_val = y_val - 1;
        		array[x_val][y_val - 1] = 4;
        		//Turn or go backwards function
        	}//End if

        	else			//Goes forwards
        	{
        		//Move forwards function
        		y_val--;
        	}

         break;
		}//End case 3


		//If facing West
    case 4:
    {

			if(SensorValue(sonarSensor) < 25)			//Detects block
      {
     		blockpose1_x_val = x_val - 1;
      	blockpose1_y_val = y_val;
        array[x_val - 1][y_val] = 4;
        //Turn or go backwards
       }//End if

       else			//Goes forwards
       {
        //Move forwards function
        x_val--;
       }

       break;
      }//End case 4

	}//End switch



   /*               Turning (for function)            */

   //Turn right
   direct++;
   if(direct == 5)  //Turning West to North correction
   {
       direct = 1;
   }

   //Turn left
   direct--;
   if(direct == 0)  //Turning North to West correction
   {
       direct = 4;
   }

}//End direction_fxn()
